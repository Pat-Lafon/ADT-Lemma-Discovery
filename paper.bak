\section{Motivation}

\textcolor{blue}{TODO: Some description about client-library verification, and why there are two examples.}

Definition of the predicates(\textcolor{blue}{they are different symbols from DOrder's to avoid confusions}).

The membership predicate is $l \triangleright u$, which means list $l$ contains element $u$.

The next predicate is $l: u \hookrightarrow v$, which means $u$ appears right after $v$ in the list $l$.

The reach predicate is $l: u \leadsto v$, which means $u$ can finally reach $v$ in the list $l$ with unknown steps. The reach predicate can benefit the representation of ordering relation in a list.

\textcolor{blue}{TODO: Here should be a tables explain the details of the definition.}

Notice that $l: u \hookrightarrow v$ implies $l: u \leadsto v$, the opposite is not true. Actually we have the following constraint:
\begin{align*}
    \forall u\ v, l: u \leadsto v \iff (l: u \hookrightarrow v \lor (\exists w, l: u \hookrightarrow w \land l: w \leadsto v))
\end{align*}
which means that "$u$ can reach $v$" is equal to "$u$ can reach $v$ in one step" or "$u$ can reach $w$ in one step and $w$ can reach $v$".

Here is a client-library program.

\begin{lstlisting}[language=ML]
(* library *)
let rec contain l x =
  match l with
  | [] -> false
  | h :: t ->
    if h = x then true
    else contain t x
let rec rm_dup l0 l1 =
  match l1 with
  | [] -> []
  | h :: t -> 
    if contain l0 h 
    then rm_dup l0 t 
    else h :: (rm_dup l0 t)
let rec uappend l0 l1 =
  l1 @ (rm_dup l0 l1)
(* client *)
let l0 = _ in
let l1 = _ in
let l2 = uappend l0 l1 in
assert post_cond l0 l1 l2;;
\end{lstlisting}

$uappend$ is a library function call who append the second list to the back of the first list but not elements already in the first list. Assume that we already have a library specification:
\begin{align*}
    \forall u\ v,&\neg l_0 \triangleright u \land \neg l_0 \triangleright v \Rightarrow ((l_2: u \leadsto v \Rightarrow l_1: u \leadsto v) \land\\
    &(l_1: u \leadsto v \land \neg l_1: v \leadsto u \Rightarrow l_2: u \leadsto v))
\end{align*}

The specification of function $uappend$ says, if the elements in $l_1$ does not appears in $l_0$, the order of them should be keep; on the other hand, if the elements in the output list do not appear in $l_0$, they must come from $l_1$ with the same order.

\subsection{Problem 1: when specification is too weak to verify the client}

A reasonable post-condition is: if the elements in both $l_0$ and $l_1$ are distinct, the elements in $l_2$ should also be distinct. It is true because $uappend$ does not append duplicates.
\begin{align*}
    &(\forall u\ v, (l_0: u \leadsto v \lor l_1: u \leadsto v) \Rightarrow \neg u = v) \Rightarrow \\
    &(\forall u\ v, l_2: u \leadsto v \Rightarrow \neg u = v)
\end{align*}

Although the existing specification implies:
\begin{align*}
    \forall u\ v,&\neg l_0 \triangleright u \land \neg l_0 \triangleright v \land l_2: u \leadsto v \Rightarrow l_1: u \leadsto v
\end{align*}

It is still too weak to proof the post condition because it talks nothing about the case besides $\neg l_0 \triangleright u \land \neg l_0 \triangleright v$. Thus sometimes the library specification is too weak to prove the client's assertion.

\subsection{Problem 2: when specification is too strong to verify the client}

Another reasonable post-condition is: if the elements in $l_1$ is already distinct, the output $l_2$ should be appended to $l_1$ directly, which means keep the next relation. It is true because $uappend$ just works like normal append function if "$contain\ l_0\ h$" in line $12$ always returns false.
\begin{align*}
    (\forall u\ v, &(l_1: u \leadsto v \Rightarrow \neg u = v) \land (l_1 \triangleright u \Rightarrow \neg l_0 \triangleright u)) \Rightarrow \\
    (\forall u\ v, &l_1: u \hookrightarrow v \Rightarrow l_2: u \hookrightarrow v)
\end{align*}

The library specification is actually strong enough to prove the post-condition. As "$l_1 \triangleright u \Rightarrow \neg l_0 \triangleright u$" implies $\neg(l_0 \triangleright u \lor l_0 \triangleright v)$, "$l_1: u \leadsto v \Rightarrow \neg u = v$" implies "$l_1: u \leadsto v \Rightarrow \neg l_1: v \leadsto u$", the library specification implies $l_2: u \leadsto v \iff l_1: u \leadsto v$. 

If two list has exactly the same reachability, and all elements are distinct, they are the same list, thus the next relation should also be kept(\textcolor{blue}{TODO: the proof should be in the appendix}). However, this involves inductive proof, which cannot be solve by SMT solver automatically. The SMT solver will try to unfold the reach predicate "$l: u \leadsto v$" as "$l:u \hookrightarrow w \land l: w \leadsto v$" which is actually unrolling an inductive definition and ends up with a infinite loop(\textcolor{blue}{TODO: z3 file required}).

This happens because the specification is too strong. Each reachability predicate actually encodes a complicate relation involves induction. On the other hand, the next predicate is quite simple. For this particular problem, $l_1: u \hookrightarrow v \Rightarrow l_2: u \hookrightarrow v$ is sufficient to prove the post-condition, although it is much weaker than $l_1: u \leadsto v \iff l_2: u \leadsto v$(as $l_1: u \hookrightarrow v \Rightarrow l_2: u \hookrightarrow v$ can not imply $l_1: u \leadsto v \iff l_2: u \leadsto v$).

\subsection{Problem 1: Abduction Synthesis Solution}

An abduction based specification synthesis plus a underline implementation inquiring based refinement can infer a specification which is strong enough to prove the post condition. To solve this problem by abduction, first assume the specification of the library function $uappend$ is an unknown specification $\gamma$ and,
\begin{align*}
    &(\forall u\ v, (l_0: u \leadsto v \lor l_1: u \leadsto v) \Rightarrow \neg u = v) \land \gamma \not \models false\\
    &(\forall u\ v, (l_0: u \leadsto v \lor l_1: u \leadsto v) \Rightarrow \neg u = v) \land \gamma \models\\
    &(\forall u\ v, l_2: u \leadsto v \Rightarrow \neg u = v)
\end{align*}

The abduction can always infer a specification which make the client verification success. Here is an example:
\begin{align*}
    \forall u\ v, l_2: u \leadsto v \Rightarrow (l_0: u \leadsto v \lor l_1: u \leadsto v)
\end{align*}

However as the "top down" abduction based synthesis just focuses on the client code, the inferred specification may inconsistent with the underline implementation. $l_2: u \leadsto v \Rightarrow l_0: u \leadsto v$ is wrong here as the following counter-examples:
\begin{align*}
    &\{l_0: [0],l_1: [1],l_2: [0;1]\}\\
    &\{l_0: [0;1],l_1: [0;2],l_2: [0;1;2]\}
\end{align*}

A underline implementation inquiring can provide more information to abduction in the top level thus refine the specification. Convert these counter-examples to positive samples and generate corresponding negative samples:
\begin{align*}
Samples^+:&\\
    &\{l_0: [0],l_1: [1],l_2: [0;1]\}\\
    &\{l_0: [0;1],l_1: [1;2],l_2: [0;1;2]\}\\
Samples^-:&\\
    &\{l_0: [0],l_1: [1],l_2: []\}\\
    &\{l_0: [0;1],l_1: [0;2],l_2: [0;2;1]\}
\end{align*}
where negative samples have the same $l_0$ and $l_1$ but can make the specification hold. A data driven synthesizer can synthesize a underline inquiring result $\mu$,
\begin{align*}
    \forall u\ v,&(\neg l_0 \triangleright u \land \neg l_0 \triangleright v \Rightarrow \\
    &\ \ (l_2: u \leadsto v \iff l_1: u \leadsto v)) \land \\
    &(l_0 \triangleright u \land \neg l_0 \triangleright v \Rightarrow \\
    &\ \ (l_2: u \leadsto v \iff l_1 \triangleright v \land \neg u = v))
\end{align*}

Then we plug the underline inquiring result back to the top level and do abduction again.
\begin{align*}
    &(\forall u\ v, (l_0: u \leadsto v \lor l_1: u \leadsto v) \Rightarrow \neg u = v) \land \mu \land \gamma \not \models false\\
    &(\forall u\ v, (l_0: u \leadsto v \lor l_1: u \leadsto v) \Rightarrow \neg u = v) \land \mu \land \gamma \models\\
    &(\forall u\ v, l_2: u \leadsto v \Rightarrow \neg u = v)
\end{align*}

New abduction is more precise than before as the addition of $\mu$, a new $\gamma$ may be,
\begin{align*}
    \forall u\ v,l_0 \triangleright v \land l_2: u \leadsto v \Rightarrow l_0: u \leadsto v
\end{align*}

The finial synthesized specification conjuncts the inquiring result and abduction result,
\begin{align*}
    \forall u\ v,&(\neg l_0 \triangleright u \land \neg l_0 \triangleright v \Rightarrow \\
    &\ \ (l_2: u \leadsto v \iff l_1: u \leadsto v)) \land \\
    &(l_0 \triangleright u \land \neg l_0 \triangleright v \Rightarrow \\
    &\ \ (l_2: u \leadsto v \iff l_1 \triangleright v \land \neg u = v)) \land \\
    &(l_0 \triangleright v \land l_2: u \leadsto v \Rightarrow l_0: u \leadsto v)
\end{align*}
which is stronger than the old library specification and also verifies the post-condition properly.

\subsection{Problem 2: Abduction Synthesis Solution}

The abduction can also avoid the specification be too strong to verify the client code. Assume the library function $uappend$ has an unknown specification $\gamma$ so that,
\begin{align*}
    &(\forall u\ v, (l_1: u \leadsto v \Rightarrow \neg u = v) \land (l_1 \triangleright u \Rightarrow \neg l_0 \triangleright u)) \land \gamma \not \models false\\
    &(\forall u\ v, (l_1: u \leadsto v \Rightarrow \neg u = v) \land (l_1 \triangleright u \Rightarrow \neg l_0 \triangleright u)) \land \gamma \models \\
    &(\forall u\ v, l_1: u \hookrightarrow v \Rightarrow l_2: u \hookrightarrow v)
\end{align*}

One possible abduction result is,
\begin{align*}
    \forall u\ v, \neg l_0 \triangleright u \land \neg l_0 \triangleright v \land l_1: u \hookrightarrow v  \Rightarrow l_2:u \hookrightarrow v
\end{align*}

This abduction result is weaker than the old library specification, as the old library specification can implies the abduction result, however the opposite is not true. 

